-- Enable PostGIS if available (optional, but good for maps)
-- create extension if not exists postgis;

-- 1. Profiles Table (Extends auth.users)
create table public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  name text,
  phone text,
  role text check (role in ('admin', 'restaurant', 'driver')),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 2. Zones Table
create table public.zones (
  id bigint generated by default as identity primary key,
  name text not null,
  boundaries jsonb, -- Store coordinates as JSON array
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 3. Branches Table
create table public.branches (
  id bigint generated by default as identity primary key,
  restaurant_name text not null,
  restaurant_id uuid references public.profiles(id),
  lat double precision,
  lng double precision,
  zone_id bigint references public.zones(id),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 4. Drivers Profiles Table
create table public.drivers_profiles (
  id uuid references public.profiles(id) primary key,
  current_lat double precision,
  current_lng double precision,
  is_available boolean default false,
  wallet_balance numeric default 0.0,
  current_zone bigint references public.zones(id),
  updated_at timestamp with time zone default timezone('utc'::text, now())
);

create table public.orders (
  id bigint generated by default as identity primary key,
  branch_id bigint references public.branches(id),
  driver_id uuid references public.profiles(id),
  status text check (status in ('pending', 'accepted', 'picked_up', 'delivered', 'cancelled')) default 'pending',
  customer_details jsonb, -- { "name": "...", "phone": "...", "address": "..." }
  price numeric default 0.0,
  delivery_fee numeric default 0.0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 6. Wallet Transactions Table
create table public.wallet_transactions (
  id bigint generated by default as identity primary key,
  driver_id uuid references public.profiles(id),
  amount numeric not null,
  type text check (type in ('deposit', 'withdrawal', 'delivery_fee', 'commission')),
  naemi_percentage numeric default 0.0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Row Level Security (RLS) Policies (Basic Examples)
alter table public.profiles enable row level security;
alter table public.zones enable row level security;
alter table public.branches enable row level security;
alter table public.orders enable row level security;
alter table public.drivers_profiles enable row level security;
alter table public.wallet_transactions enable row level security;

-- Policies
-- 1. Profiles: Users can read their own profile.
drop policy if exists "Public profiles are viewable by everyone" on public.profiles;
drop policy if exists "Users can view own profile" on public.profiles;
drop policy if exists "Admins can view all profiles" on public.profiles;

create policy "Users can view own profile" on public.profiles for select
using (auth.uid() = id);

create policy "Admins can view all profiles" on public.profiles for select
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);
create policy "Users can insert their own profile" on public.profiles for insert
with check (auth.uid() = id and role = 'driver');

create policy "Users can update own profile" on public.profiles for update
using (auth.uid() = id)
with check (
  auth.uid() = id
  and role = (
    select p.role
    from public.profiles p
    where p.id = auth.uid()
  )
);

create policy "Admins can update profiles" on public.profiles for update
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create or replace function public.enforce_profile_role_change()
returns trigger
language plpgsql
security definer
as $$
begin
  if new.role is distinct from old.role then
    if auth.uid() is null then
      return new;
    end if;
    if not exists (
      select 1
      from public.profiles p
      where p.id = auth.uid()
        and p.role = 'admin'
    ) then
      raise exception 'Only admins can change role';
    end if;
  end if;
  return new;
end;
$$;

drop trigger if exists enforce_profile_role_change on public.profiles;
create trigger enforce_profile_role_change
before update on public.profiles
for each row
execute function public.enforce_profile_role_change();

create policy "Admins can view zones" on public.zones for select
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create policy "Restaurants can view own branches" on public.branches for select
using (restaurant_id = auth.uid());

create policy "Admins can view all branches" on public.branches for select
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create policy "Drivers can view branches for visible orders" on public.branches for select
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'driver'
  )
  and
  exists (
    select 1
    from public.orders o
    where o.branch_id = branches.id
      and (o.status = 'pending' or o.driver_id = auth.uid())
  )
);

create policy "Drivers can view own driver profile" on public.drivers_profiles for select
using (id = auth.uid());

create policy "Drivers can update own driver profile" on public.drivers_profiles for update
using (id = auth.uid())
with check (id = auth.uid());

create policy "Drivers can insert own driver profile" on public.drivers_profiles for insert
with check (id = auth.uid() and wallet_balance = 0);

create policy "Drivers can view own wallet transactions" on public.wallet_transactions for select
using (driver_id = auth.uid());

revoke insert on public.wallet_transactions from authenticated;
grant select on public.wallet_transactions to authenticated;

revoke insert on public.drivers_profiles from authenticated;
revoke update on public.drivers_profiles from authenticated;

grant insert (id, current_lat, current_lng, is_available, current_zone, updated_at)
  on public.drivers_profiles to authenticated;

grant update (current_lat, current_lng, is_available, current_zone, updated_at)
  on public.drivers_profiles to authenticated;

revoke insert (wallet_balance) on public.drivers_profiles from authenticated;
revoke update (wallet_balance) on public.drivers_profiles from authenticated;

-- 2. Orders:
-- Admin sees all.
-- Restaurant sees orders for their branch (need logic linking user to branch, simplified here).
-- Driver sees available orders or orders assigned to them.
create policy "Drivers can view available or assigned orders" on public.orders for select
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'driver'
  )
  and
  (status = 'pending' or driver_id = auth.uid())
);

create policy "Restaurants can view orders for own branches" on public.orders for select
using (
  exists (
    select 1
    from public.branches b
    where b.id = orders.branch_id
      and b.restaurant_id = auth.uid()
  )
);

create policy "Restaurants can create orders for own branches" on public.orders for insert
with check (
  exists (
    select 1
    from public.branches b
    where b.id = orders.branch_id
      and b.restaurant_id = auth.uid()
  )
);

create policy "Admins can view all orders" on public.orders for select
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create policy "Admins can view all driver profiles" on public.drivers_profiles for select
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create or replace view public.driver_orders_with_branch
with (security_barrier = true)
as
select
  o.id as order_id,
  o.status,
  o.driver_id,
  o.branch_id,
  ('فرع #' || b.id::text) as branch_name,
  b.lat,
  b.lng,
  b.restaurant_name
from public.orders o
join public.branches b on b.id = o.branch_id
where o.status = 'pending' or o.driver_id = auth.uid();

grant select on public.driver_orders_with_branch to authenticated;

-- Atomic accept order (prevents race condition)
create or replace function public.accept_order(p_order_id bigint)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  v_driver_id uuid := auth.uid();
  v_role text;
  v_status text;
  v_existing_driver uuid;
begin
  if v_driver_id is null then
    raise exception 'Not authenticated';
  end if;

  select role into v_role from public.profiles where id = v_driver_id;
  if v_role is distinct from 'driver' then
    raise exception 'Only drivers can accept orders';
  end if;

  select status, driver_id
  into v_status, v_existing_driver
  from public.orders
  where id = p_order_id
  for update;

  if not found then
    return 'already_taken';
  end if;

  if v_status is distinct from 'pending' or v_existing_driver is not null then
    return 'already_taken';
  end if;

  update public.orders
  set status = 'accepted',
      driver_id = v_driver_id
  where id = p_order_id;

  if found then
    return 'success';
  end if;

  return 'already_taken';
end;
$$;

grant execute on function public.accept_order(bigint) to authenticated;

-- Atomic pickup order (prevents race & direct client updates)
create or replace function public.pickup_order(p_order_id bigint)
returns text
language plpgsql
security definer
set search_path = public
as $$
declare
  v_driver_id uuid := auth.uid();
  v_role text;
  v_status text;
  v_assigned_driver uuid;
begin
  if v_driver_id is null then
    raise exception 'Not authenticated';
  end if;

  select role into v_role from public.profiles where id = v_driver_id;
  if v_role is distinct from 'driver' then
    raise exception 'Only drivers can pickup orders';
  end if;

  select status, driver_id
  into v_status, v_assigned_driver
  from public.orders
  where id = p_order_id
  for update;

  if not found then
    return 'already_taken';
  end if;

  if v_assigned_driver is distinct from v_driver_id then
    return 'already_taken';
  end if;

  if v_status is distinct from 'accepted' then
    return 'already_taken';
  end if;

  update public.orders
  set status = 'picked_up'
  where id = p_order_id
    and driver_id = v_driver_id
    and status = 'accepted';

  if found then
    return 'success';
  end if;

  return 'already_taken';
end;
$$;

grant execute on function public.pickup_order(bigint) to authenticated;

revoke update on public.orders from authenticated;

-- Atomic complete order + wallet increment (prevents wallet race condition)
create or replace function public.complete_order(p_order_id bigint)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  v_driver_id uuid := auth.uid();
  v_role text;
  v_delivery_fee numeric;
  v_order_status text;
begin
  if v_driver_id is null then
    raise exception 'Not authenticated';
  end if;

  select role into v_role from public.profiles where id = v_driver_id;
  if v_role is distinct from 'driver' then
    raise exception 'Only drivers can complete orders';
  end if;

  select delivery_fee, status
  into v_delivery_fee, v_order_status
  from public.orders
  where id = p_order_id
    and driver_id = v_driver_id
  for update;

  if not found then
    return false;
  end if;

  if v_order_status = 'delivered' or v_order_status = 'cancelled' then
    return false;
  end if;

  update public.orders
  set status = 'delivered'
  where id = p_order_id
    and driver_id = v_driver_id
    and status <> 'delivered'
    and status <> 'cancelled';

  if not found then
    return false;
  end if;

  insert into public.drivers_profiles (id, wallet_balance)
  values (v_driver_id, 0)
  on conflict (id) do nothing;

  update public.drivers_profiles
  set wallet_balance = wallet_balance + coalesce(v_delivery_fee, 0)
  where id = v_driver_id;

  insert into public.wallet_transactions (driver_id, amount, type, naemi_percentage, created_at)
  values (
    v_driver_id,
    coalesce(v_delivery_fee, 0),
    'delivery_fee',
    coalesce(v_delivery_fee, 0) * 0.20,
    timezone('utc'::text, now())
  );

  return true;
end;
$$;

grant execute on function public.complete_order(bigint) to authenticated;

-- Function to handle new user signup (Trigger)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, email, role, name)
  values (new.id, new.email, 'driver', new.raw_user_meta_data->>'name');

  update public.profiles
  set phone = nullif(new.raw_user_meta_data->>'phone', '')
  where id = new.id;
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
